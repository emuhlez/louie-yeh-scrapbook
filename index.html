<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Memory Scrapbook v2</title>
  
  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@300;400;600;700&family=Inter:wght@300;400;500;600;700&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
  
  <!-- GSAP for smooth animations -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
  
  <style>
    /* Version 2.0 - Updated with analog film effects */
    /* ============================================
       CSS VARIABLES - STRICT COLOR PALETTE
       ============================================ */
    :root {
      --bg-main: #ffffff;
      --bg-card: #F5F2EC;
      --text-primary: #000000;
      --text-secondary: #646464;
      --accent-neutral: #2D2520;
      --accent-light: #8B8680;
      --shadow-soft: rgba(45, 37, 32, 0.08);
      --shadow-medium: rgba(45, 37, 32, 0.15);
    }
    
    /* ============================================
       RESET & BASE STYLES
       ============================================ */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'IBM Plex Mono', monospace;
      font-weight: 400;
      color: var(--text-primary);
      background: linear-gradient(135deg, #faf8f5 0%, #f5f0e8 100%);
      min-height: 100vh;
      position: relative;
      overflow-x: hidden;
    }
    
    /* Radial gradient overlays for depth */
    body::before,
    body::after {
      content: '';
      position: fixed;
      border-radius: 50%;
      pointer-events: none;
      z-index: 0;
    }
    
    body::before {
      width: 800px;
      height: 800px;
      top: -400px;
      right: -400px;
      background: radial-gradient(circle, var(--accent-light) 0%, transparent 70%);
      opacity: 0.02;
    }
    
    body::after {
      width: 600px;
      height: 600px;
      bottom: -300px;
      left: -300px;
      background: radial-gradient(circle, var(--accent-light) 0%, transparent 70%);
      opacity: 0.02;
    }
    
    /* ============================================
       TYPOGRAPHY
       ============================================ */
    h1, h2, h3 {
      font-family: 'IBM Plex Mono', monospace;
      font-weight: 700;
    }
    
    h1 {
      font-size: clamp(2rem, 5vw, 3rem);
    }
    
    h2 {
      font-size: clamp(1.5rem, 4vw, 2rem);
    }
    
    h3 {
      font-size: clamp(1.2rem, 3vw, 1.5rem);
    }
    
    p, label, button {
      font-family: 'IBM Plex Mono', monospace;
    }
    
    /* Secondary font for captions and letters */
    .caption,
    .letter-content,
    .memory-caption,
    .memory-text {
      font-family: 'Inter', sans-serif;
    }
    
    /* ============================================
       ANIMATIONS
       ============================================ */
    @keyframes fadeIn {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }
    
    @keyframes fadeInDown {
      from {
        opacity: 0;
        transform: translateY(-20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    /* ============================================
       CONTAINER & LAYOUT
       ============================================ */
    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 2rem;
      position: relative;
      z-index: 1;
    }
    
    /* ============================================
       HEADER - Removed
       ============================================ */
    
    /* ============================================
       BUTTONS
       ============================================ */
    button {
      font-size: 1rem;
      font-weight: 600;
      padding: 0.8rem 2rem;
      border: none;
      border-radius: 50px;
      background: var(--text-primary);
      color: white;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 4px 15px var(--shadow-soft);
    }
    
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px var(--shadow-medium);
    }
    
    button:active {
      transform: translateY(0);
    }
    
    /* ============================================
       CARDS
       ============================================ */
    .card {
      background: var(--bg-card);
      border-radius: 16px;
      padding: 1.5rem;
      box-shadow: 0 4px 20px var(--shadow-soft);
      transition: all 0.3s ease;
    }
    
    .card:hover {
      transform: translateY(-4px);
      box-shadow: 0 8px 30px var(--shadow-medium);
    }
    
    /* ============================================
       MAIN CONTENT AREA
       ============================================ */
    main {
      min-height: 60vh;
      animation: fadeInUp 0.8s ease;
      padding-top: 2rem;
    }
    
    /* ============================================
       ACTION BUTTONS
       ============================================ */
    .action-bar {
      display: flex;
      justify-content: center;
      margin-bottom: 2rem;
    }
    
    .create-memory-btn {
      font-size: 1.1rem;
      padding: 1rem 2.5rem;
    }
    
    /* ============================================
       3D SCROLL VIEW - CAROUSEL STYLE
       ============================================ */
    .carousel-view {
      width: 100%;
      height: 85vh;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      background: unset;
      margin: 0 -2rem;
      padding: 2rem;
      perspective: 1200px;
    }
    
    .carousel-stage {
      position: relative;
      width: 100%;
      height: 100%;
      display: grid;
      place-items: center;
      perspective: 1200px;
      background: transparent;
    }
    
    /* The ONLY thing that gets transform animations */
    .carousel-card {
      position: absolute;
      width: clamp(220px, 45vw, 460px);
      aspect-ratio: 3 / 4;
      border-radius: 0;
      overflow: hidden;
      will-change: transform, opacity;
      transform-style: preserve-3d;
      backface-visibility: hidden;
      -webkit-backface-visibility: hidden;
      transform-origin: 50% 50%;
      
      /* Critical: stable clipping + GPU */
      transform: translate3d(0,0,0);
      -webkit-mask-image: -webkit-radial-gradient(white, black); /* Safari/Chrome "triangle tear" fix */
      
      border: none;
      outline: none;
    }
    
    /* Inner should NOT be 3D or clipped */
    .print {
      position: relative;
      width: 100%;
      height: 100%;
      border-radius: 0;
      overflow: visible;
      transform: translateZ(0);
      isolation: isolate;
      box-shadow: 0 20px 60px rgba(0,0,0,.4);
    }
    
    .print img,
    .print video {
      width:100%;
      height:100%;
      object-fit:cover;
      display:block;
      border-radius:0;
      border: none;
      outline: none;
    }
    
    /* Effect layers for realistic photo feel */
    .paper, .sheen, .bend, .curl, .dust {
      position: absolute;
      inset: 0;
      pointer-events: none;
      transform: translateZ(0);
      backface-visibility: hidden;
    }
    
    /* Blend modes - prevent leaking across layers when compositing */
    .paper, .bend, .curl, .dust { 
      mix-blend-mode: normal; 
    }
    
    .sheen { 
      mix-blend-mode: screen; 
      background: linear-gradient(135deg, 
        transparent 0%, 
        rgba(255,255,255,0.03) 30%, 
        rgba(255,255,255,0.08) 50%, 
        rgba(255,255,255,0.03) 70%, 
        transparent 100%
      );
      opacity: 0.6;
    }
    
    .paper {
      background: rgba(255,255,255,0.015);
    }
    
    /* Placeholder for content */
    .content-placeholder {
      text-align: center;
      padding: 4rem 2rem;
      color: var(--text-secondary);
    }
    
    /* ============================================
       MODAL
       ============================================ */
    .modal-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(8px);
      z-index: 1000;
      display: none;
      align-items: center;
      justify-content: center;
      animation: fadeIn 0.3s ease;
    }
    
    .modal-backdrop.active {
      display: flex;
    }
    
    .modal {
      background: var(--bg-card);
      border-radius: 16px;
      padding: 2rem;
      max-width: 600px;
      width: 90%;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
      animation: fadeInUp 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      transform-origin: center;
    }
    
    .modal-header {
      margin-bottom: 1.5rem;
    }
    
    .modal-header h2 {
      color: var(--text-primary);
      margin-bottom: 0.5rem;
    }
    
    .modal-header p {
      color: var(--text-secondary);
      font-size: 0.95rem;
    }
    
    .modal-close {
      position: absolute;
      top: 1rem;
      right: 1rem;
      background: transparent;
      border: none;
      font-size: 1.5rem;
      color: var(--text-secondary);
      cursor: pointer;
      padding: 0.5rem;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
    }
    
    .modal-close:hover {
      background: rgba(0, 0, 0, 0.05);
      color: var(--text-primary);
      transform: none;
    }
    
    /* ============================================
       FORM STYLES
       ============================================ */
    .form-group {
      margin-bottom: 1.5rem;
    }
    
    .form-group label {
      display: block;
      margin-bottom: 0.5rem;
      color: var(--text-primary);
      font-weight: 600;
      font-size: 0.95rem;
    }
    
    .form-group input,
    .form-group textarea,
    .form-group select {
      width: 100%;
      padding: 0.8rem;
      border: 1px solid rgba(45, 37, 32, 0.2);
      border-radius: 8px;
      font-family: 'Inter', sans-serif;
      font-size: 0.95rem;
      color: var(--text-primary);
      background: var(--bg-main);
      transition: all 0.3s ease;
    }
    
    .form-group input:focus,
    .form-group textarea:focus,
    .form-group select:focus {
      outline: none;
      border-color: var(--text-primary);
      box-shadow: 0 0 0 3px rgba(45, 37, 32, 0.1);
    }
    
    .form-group textarea {
      min-height: 120px;
      resize: vertical;
    }
    
    .memory-type-selector {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 0.75rem;
      margin-top: 0.5rem;
    }
    
    .type-option {
      padding: 1rem;
      border: 2px solid rgba(45, 37, 32, 0.15);
      border-radius: 12px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
      background: var(--bg-main);
    }
    
    .type-option:hover {
      border-color: var(--text-primary);
      transform: translateY(-2px);
    }
    
    .type-option.active {
      border-color: var(--text-primary);
      background: rgba(45, 37, 32, 0.05);
    }
    
    .type-option-icon {
      font-size: 1.5rem;
      margin-bottom: 0.5rem;
    }
    
    .type-option-label {
      font-size: 0.85rem;
      color: var(--text-primary);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .form-actions {
      display: flex;
      gap: 1rem;
      justify-content: flex-end;
      margin-top: 2rem;
    }
    
    .form-actions button {
      padding: 0.8rem 1.8rem;
    }
    
    .btn-secondary {
      background: transparent;
      border: 2px solid var(--text-secondary);
      color: var(--text-secondary);
    }
    
    .btn-secondary:hover {
      background: rgba(0, 0, 0, 0.05);
      border-color: var(--text-primary);
      color: var(--text-primary);
    }
    
    /* ============================================
       LANDING PAGE
       ============================================ */
    .landing-page {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: linear-gradient(135deg, #fdfcfb 0%, #f7f5f2 50%, #fdfcfb 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2000;
      overflow: hidden;
      transition: opacity 0.6s ease, transform 0.6s ease;
    }
    
    .landing-page::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 120%;
      height: 120%;
      background: radial-gradient(circle, transparent 0%, rgba(0,0,0,0.02) 100%);
      pointer-events: none;
    }
    
    .landing-page.hidden {
      opacity: 0;
      pointer-events: none;
      transform: scale(0.95);
    }
    
    .landing-title {
      text-align: center;
      cursor: pointer;
      z-index: 10;
      position: relative;
      padding: 2rem;
      transition: all 0.5s ease;
      user-select: none;
      max-width: 90%;
      width: auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.5rem;
      animation: landingTitleFadeIn 1s ease forwards;
    }
    
    @keyframes landingTitleFadeIn {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    .landing-title-main {
      width: 100%;
      max-width: 600px;
      height: auto;
      display: block;
      transition: all 0.3s ease;
    }
    
    .landing-title-sub {
      width: 100%;
      max-width: 350px;
      height: auto;
      display: block;
      margin-left: 60px;
      transition: all 0.3s ease;
    }
    
    .landing-title:hover .landing-title-main,
    .landing-title:hover .landing-title-sub {
      transform: scale(1.05);
      opacity: 0.7;
    }
    
    .photo-stream {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: none;
      overflow: hidden;
      perspective: 1200px;
    }
    
    .photo-stream-item {
      position: absolute;
      animation: streamLeft 30s linear infinite;
      white-space: nowrap;
      will-change: transform;
      pointer-events: auto;
      cursor: pointer;
      transform-style: preserve-3d;
      backface-visibility: hidden;
    }
    
    .stream-photo {
      width: auto;
      height: 200px;
      border-radius: 0;
      object-fit: contain;
      box-shadow: 0 4px 20px var(--shadow-soft);
      opacity: 1;
      display: block;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
      background: transparent;
      transform-style: preserve-3d;
      backface-visibility: hidden;
    }
    
    .photo-stream-item:hover .stream-photo {
      transform: scale(1.1);
      box-shadow: 0 8px 30px var(--shadow-medium);
      z-index: 100;
    }
    
    @keyframes streamLeft {
      0% {
        transform: translateX(0);
      }
      100% {
        transform: translateX(-200vw);
      }
    }
    
    /* Minimal fade animation */
    .photo-stream-item.fade-out {
      transition: opacity 1.2s ease, transform 1.2s ease;
    }
    
    /* ============================================
       MOBILE RESPONSIVENESS
       ============================================ */
    @media (max-width: 768px) {
      .container {
        padding: 1rem;
      }
      
      button {
        padding: 0.7rem 1.5rem;
        font-size: 0.9rem;
      }
      
      .memory-type-selector {
        grid-template-columns: repeat(3, 1fr);
      }
      
      .modal {
        width: 95%;
        padding: 1.5rem;
      }
      
      .form-actions {
        flex-direction: column;
      }
      
      .form-actions button {
        width: 100%;
      }
      
      .stream-photo {
        height: 160px !important;
      }
      
      .landing-title-main {
        max-width: 90%;
      }
      
      .landing-title-sub {
        max-width: 70%;
        margin-left: 40px;
      }
      
      /* Carousel view mobile adjustments */
      .carousel-view {
        height: 75vh;
        margin: 0 -1rem;
        padding: 1rem;
      }
      
      .carousel-card {
        width: clamp(200px, 65vw, 360px);
      }
      
    }
  </style>
</head>
<body>
  <!-- Landing Page -->
  <div class="landing-page" id="landingPage">
    <div class="photo-stream" id="photoStream">
      <!-- Photo streams will be generated here -->
    </div>
    <div class="landing-title" id="landingTitle">
      <img class="landing-title-main" src="title/nate-emily-goose.svg" alt="nate + emily + goose">
      <img class="landing-title-sub" src="title/Scrapbook.svg" alt="scrapbook">
    </div>
  </div>
  
  <div class="container">
    
    <main>
      <div class="action-bar">
        <button class="create-memory-btn" id="createMemoryBtn">+ Create Memory</button>
      </div>
      
      <div id="app-content">
        <!-- Content will be rendered here -->
      </div>
    </main>
  </div>
  
  <!-- Create Memory Modal -->
  <div class="modal-backdrop" id="createMemoryModal">
    <div class="modal">
      <div class="modal-header">
        <h2>Create a New Memory</h2>
        <p>Choose a type and fill in the details</p>
      </div>
      
      <form id="createMemoryForm">
        <div class="form-group">
          <label>Memory Type</label>
          <div class="memory-type-selector">
            <div class="type-option" data-type="letter">
              <div class="type-option-icon">‚úâÔ∏è</div>
              <div class="type-option-label">Letter</div>
            </div>
            <div class="type-option" data-type="photo">
              <div class="type-option-icon">üì∑</div>
              <div class="type-option-label">Photo</div>
            </div>
            <div class="type-option" data-type="video">
              <div class="type-option-icon">üé¨</div>
              <div class="type-option-label">Video</div>
            </div>
          </div>
          <input type="hidden" id="memoryType" name="type" required>
        </div>
        
        <div class="form-group">
          <label for="memoryTitle">Title</label>
          <input type="text" id="memoryTitle" name="title" placeholder="Give this memory a name" required>
        </div>
        
        <div class="form-group">
          <label for="memoryDate">Date</label>
          <input type="date" id="memoryDate" name="date" required>
        </div>
        
        <div class="form-group">
          <label for="memoryContent">Content</label>
          <textarea id="memoryContent" name="content" placeholder="Select a memory type first..." required></textarea>
        </div>
        
        <div class="form-group" id="captionField" style="display: none;">
          <label for="memoryCaption">Caption (optional)</label>
          <input type="text" id="memoryCaption" name="caption" placeholder="A short description">
        </div>
        
        <div class="form-actions">
          <button type="button" class="btn-secondary" id="cancelBtn">Cancel</button>
          <button type="submit">Create Memory</button>
        </div>
      </form>
    </div>
  </div>
  
  <script>
    // Polyfill for window.storage if not available (fallback to localStorage)
    if (typeof window.storage === 'undefined') {
      console.log('window.storage not available, using localStorage fallback');
      window.storage = {
        async set(key, value) {
          localStorage.setItem(key, value);
          return { success: true };
        },
        async get(key) {
          const value = localStorage.getItem(key);
          return value ? { value } : null;
        },
        async list(prefix) {
          const keys = [];
          for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key.startsWith(prefix)) {
              keys.push(key);
            }
          }
          return { keys };
        },
        async delete(key) {
          localStorage.removeItem(key);
          return { success: true };
        }
      };
    }
    
    class MemoryScrapbookApp {
      constructor() {
        this.memories = [];
        this.landingActive = true;
        this.carouselIndex = 0;
        this.carouselLocked = false;
        this.carouselCards = [];
        this.carouselInitialized = false;
        this.lastMovedCard = null;
        this.isTransitioning = false;
        
        this.init();
      }
      
      async init() {
        console.log('=== APP INIT START ===');
        
        // Load memories from storage FIRST
        console.log('Loading memories...');
        await this.loadMemories();
        console.log(`Loaded ${this.memories.length} memories`);
        
        // Setup photo stream on landing page
        console.log('Setting up photo stream...');
        await this.setupPhotoStream();
        
        // Setup event listeners
        console.log('Setting up event listeners...');
        this.setupEventListeners();
        
        console.log('=== APP INIT COMPLETE ===');
        // Don't render main content until landing is dismissed
      }
      
      async loadMemories() {
        console.log('üîÑ Starting to load memories...');
        
        // Always load demo data first (all photos from directory)
        await this.loadDemoData();
        console.log(`‚úÖ Demo data loaded: ${this.memories.length} items`);
        
        // Then try to load any user-created memories from storage
        try {
          const result = await window.storage.list('memory:');
          if (result && result.keys && result.keys.length > 0) {
            console.log(`üì¶ Found ${result.keys.length} saved memories in storage`);
            const memoryPromises = result.keys.map(async key => {
              const data = await window.storage.get(key);
              return data ? JSON.parse(data.value) : null;
            });
            const savedMemories = (await Promise.all(memoryPromises)).filter(Boolean);
            
            // Merge saved memories with demo data
            this.memories = [...savedMemories, ...this.memories];
            this.memories.sort((a, b) => new Date(b.date) - new Date(a.date));
            console.log(`‚úÖ Total memories after merging: ${this.memories.length}`);
          }
        } catch (error) {
          console.warn('Storage not available, using only photo data:', error);
        }
      }
      
      async loadDemoData() {
        // Load metadata JSON file - this contains all files with their dates
        let photoMetadata = {};
        
        try {
          const response = await fetch('photo-metadata.json');
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          photoMetadata = await response.json();
          console.log(`üìÖ Loaded metadata for ${Object.keys(photoMetadata).length} files`);
        } catch (error) {
          console.error('‚ùå Could not load photo metadata:', error);
          console.log('Using generated fallback list...');
          photoMetadata = this.getGeneratedFallbackList();
        }
        
        if (Object.keys(photoMetadata).length === 0) {
          console.error('‚ùå No photos found in metadata or fallback!');
          return;
        }
        
        // Dynamically load all files from metadata
        this.memories = [];
        let photoCount = 0;
        let videoCount = 0;
        
        console.log(`üìÇ Processing ${Object.keys(photoMetadata).length} files from metadata...`);
        
        Object.entries(photoMetadata).forEach(([filename, date], index) => {
          const isVideo = filename.toLowerCase().endsWith('.mov') || filename.toLowerCase().endsWith('.mp4');
          const type = isVideo ? 'video' : 'photo';
          
          if (isVideo) {
            videoCount++;
          } else {
            photoCount++;
          }
          
          const memory = {
            id: `${type}_${index}`,
            type: type,
            date: date || '2024-01-01',
            title: filename.replace(/\.[^/.]+$/, '').replace(/_/g, ' '),
            content: `photos/${filename}`,
            caption: ''
          };
          
          this.memories.push(memory);
          
          // Log first few items for debugging
          if (index < 3) {
            console.log(`  ‚ûú Added: ${filename} (${type}, ${date})`);
          }
        });
        
        // Sort chronologically (newest first)
        this.memories.sort((a, b) => new Date(b.date) - new Date(a.date));
        
        console.log(`üì∏ Successfully loaded ${photoCount} photos and ${videoCount} videos`);
        console.log(`üìä Total memories in array: ${this.memories.length}`);
      }
      
      getGeneratedFallbackList() {
        // Auto-generated list of all current files
        const currentFiles = {
          "001_Original.jpg": "2026-01-02",
          "016_Original.jpg": "2026-01-03",
          "017_Original.jpg": "2026-01-03",
          "024_Original.jpg": "2026-01-03",
          "027_Original.jpg": "2026-01-03",
          "055_Original.jpg": "2026-01-03",
          "071_Original.jpg": "2026-01-03",
          "114_Original.jpg": "2026-01-03",
          "121_Original.jpg": "2026-01-03",
          "142_Original.jpg": "2026-01-03",
          "196_Original.jpg": "2026-01-03",
          "211_Original.jpg": "2026-01-03",
          "A20926B7-DE97-4E84-AB81-0748BE55DBDA.JPG": "2025-01-25",
          "CIMG9720.jpg": "2025-04-12",
          "IMG_0028.MOV": "2026-01-16",
          "IMG_0043.JPG": "2026-01-15",
          "IMG_0053.jpeg": "2025-01-12",
          "IMG_0184.jpeg": "2026-02-07",
          "IMG_0485.JPG": "2026-01-18",
          "IMG_0488.jpeg": "2026-01-19",
          "IMG_0526.jpeg": "2025-02-05",
          "IMG_0536.jpeg": "2025-02-06",
          "IMG_0808.jpeg": "2025-02-15",
          "IMG_0890.jpeg": "2025-02-18",
          "IMG_1002.jpeg": "2026-02-09",
          "IMG_1011.JPG": "2025-02-21",
          "IMG_1031.jpeg": "2026-02-11",
          "IMG_1053.jpeg": "2026-02-12",
          "IMG_1375.jpeg": "2025-03-06",
          "IMG_1452.jpeg": "2025-03-08",
          "IMG_1469.jpeg": "2025-03-08",
          "IMG_1585.jpeg": "2025-03-16",
          "IMG_1624.jpeg": "2025-03-21",
          "IMG_1645.jpeg": "2024-11-25",
          "IMG_1651.jpeg": "2024-11-25",
          "IMG_1657.jpeg": "2026-02-13",
          "IMG_1684.jpeg": "2025-03-23",
          "IMG_2163.jpeg": "2025-03-25",
          "IMG_2205.MOV": "2025-03-28",
          "IMG_2449.jpeg": "2025-04-13",
          "IMG_2953.jpeg": "2025-01-01",
          "IMG_2978.jpeg": "2024-11-02",
          "IMG_2979 2.jpeg": "2025-04-13",
          "IMG_2979.jpeg": "2024-11-02",
          "IMG_3013.jpeg": "2025-04-13",
          "IMG_3064.jpeg": "2025-04-14",
          "IMG_3082 2.jpeg": "2025-04-14",
          "IMG_3126.jpeg": "2025-04-14",
          "IMG_3149.jpeg": "2025-04-14",
          "IMG_3261.jpeg": "2025-04-15",
          "IMG_3263.jpeg": "2025-04-15",
          "IMG_3267.jpeg": "2025-04-15",
          "IMG_3324.JPG": "2025-04-22",
          "IMG_3384.JPG": "2025-04-22",
          "IMG_3522.jpeg": "2025-04-24",
          "IMG_3570.jpeg": "2025-04-25",
          "IMG_3583.jpeg": "2025-04-25",
          "IMG_3631.jpeg": "2025-04-26",
          "IMG_3668.jpeg": "2025-04-27",
          "IMG_4003.jpeg": "2025-05-01",
          "IMG_4053.jpeg": "2025-05-03",
          "IMG_4064.jpeg": "2025-05-03",
          "IMG_4146.jpeg": "2025-05-06",
          "IMG_4246 2.jpeg": "2025-05-09",
          "IMG_4289.jpeg": "2025-05-10",
          "IMG_4310.jpeg": "2025-05-11",
          "IMG_4430.jpeg": "2025-05-17",
          "IMG_4443.jpeg": "2025-05-17",
          "IMG_4533.MOV": "2025-06-07",
          "IMG_4652.jpeg": "2025-06-13",
          "IMG_4682.jpeg": "2025-06-15",
          "IMG_4699.jpeg": "2025-06-15",
          "IMG_5014.JPG": "2025-06-07",
          "IMG_5055.jpeg": "2025-06-21",
          "IMG_5101.jpeg": "2025-06-22",
          "IMG_5116.jpeg": "2025-06-22",
          "IMG_5209.jpeg": "2025-06-25",
          "IMG_5222.jpeg": "2025-06-26",
          "IMG_5274.jpeg": "2025-06-27",
          "IMG_5353.jpeg": "2025-07-01",
          "IMG_5379.jpeg": "2025-07-01",
          "IMG_5783.jpeg": "2025-07-13",
          "IMG_5840.jpeg": "2025-07-16",
          "IMG_5899.jpeg": "2025-07-19",
          "IMG_6006.jpeg": "2025-07-23",
          "IMG_6307.jpeg": "2025-08-12",
          "IMG_6349.jpeg": "2025-08-15",
          "IMG_6396.jpeg": "2025-08-18",
          "IMG_6397.MOV": "2025-09-12",
          "IMG_6646.jpeg": "2025-09-13",
          "IMG_6648.jpeg": "2025-09-13",
          "IMG_6789.jpeg": "2025-09-17",
          "IMG_6825.jpeg": "2025-09-19",
          "IMG_6844.jpeg": "2025-09-20",
          "IMG_6957.jpeg": "2025-09-24",
          "IMG_6957 2.jpeg": "2025-09-24",
          "IMG_7043.jpeg": "2025-09-28",
          "IMG_7051.jpeg": "2025-09-29",
          "IMG_7064.jpeg": "2025-09-30",
          "IMG_7146.jpeg": "2025-10-04",
          "IMG_7308.jpeg": "2025-10-11",
          "IMG_7435.jpg": "2025-11-08",
          "IMG_7506.jpeg": "2025-10-25",
          "IMG_7535.jpeg": "2025-10-27",
          "IMG_7600.jpeg": "2025-10-31",
          "IMG_7687.jpeg": "2025-11-04",
          "IMG_7718.jpeg": "2025-11-06",
          "IMG_7734.jpeg": "2025-11-07",
          "IMG_7791.jpeg": "2025-11-09",
          "IMG_7824.jpeg": "2025-11-11",
          "IMG_7827.JPG": "2025-11-17",
          "IMG_8316.jpeg": "2025-11-27",
          "IMG_8346.jpg": "2025-12-13",
          "IMG_8389.jpeg": "2025-11-30",
          "IMG_8468.jpeg": "2025-12-03",
          "IMG_8548.jpeg": "2025-12-06",
          "IMG_8553.jpeg": "2025-12-06",
          "IMG_8561.jpeg": "2025-12-07",
          "IMG_8583.MOV": "2025-12-14",
          "IMG_8626.JPG": "2025-12-17",
          "IMG_8627.JPG": "2025-12-17",
          "IMG_8628.JPG": "2025-12-17",
          "IMG_8634.JPG": "2025-12-17",
          "IMG_8636.JPG": "2025-12-17",
          "IMG_8690.jpeg": "2025-12-09",
          "IMG_8701.jpeg": "2025-12-09",
          "IMG_8746.jpeg": "2025-12-11",
          "IMG_8821.jpeg": "2025-12-14",
          "IMG_8823.jpeg": "2025-12-14",
          "IMG_8849.jpeg": "2025-12-15",
          "IMG_8860.JPG": "2025-12-07",
          "IMG_8897.jpeg": "2025-12-18",
          "IMG_8901.jpeg": "2025-12-18",
          "IMG_8908.jpeg": "2025-12-19",
          "IMG_8926.jpeg": "2025-12-19",
          "IMG_8952.jpeg": "2025-12-20",
          "IMG_8976.MOV": "2025-12-25",
          "IMG_8995.JPG": "2026-01-14",
          "IMG_9014.jpeg": "2025-12-21",
          "IMG_9021.jpeg": "2025-12-21",
          "IMG_9033.jpeg": "2025-12-22",
          "IMG_9036.jpeg": "2025-12-22",
          "IMG_9057.jpeg": "2025-12-23",
          "IMG_9090.jpeg": "2025-12-24",
          "IMG_9111.jpeg": "2025-12-25",
          "IMG_9122.jpeg": "2025-12-26",
          "IMG_9187.jpeg": "2025-12-28",
          "IMG_9229.jpeg": "2025-12-30",
          "IMG_9257.jpeg": "2025-12-31",
          "IMG_9294.jpeg": "2026-01-01",
          "IMG_9303.JPG": "2026-01-17",
          "IMG_9309.jpeg": "2026-01-01",
          "IMG_9317.MOV": "2026-01-01",
          "IMG_9340.jpeg": "2026-01-02",
          "IMG_9356.jpeg": "2026-01-02",
          "IMG_9378.jpeg": "2026-01-03",
          "IMG_9442.JPG": "2026-01-18",
          "IMG_9459.JPG": "2026-01-18",
          "IMG_9880.jpeg": "2026-01-11",
          "IMG_9925.jpeg": "2026-01-13",
          "IMG_9933.jpg": "2025-01-10",
          "IMG_9989.jpeg": "2026-01-14",
          "ScreenRecording_06-20-2025 21-16-11_1.mov": "2025-06-21",
          "Video Nov 08 2025, 5 12 28 PM.MOV": "2025-11-09",
          "Video Nov 08 2025, 7 45 13 PM.MOV": "2025-11-09"
        };
        return currentFiles;
      }
      
      getFallbackPhotoList() {
        // Fallback list with estimated dates
        const fallbackFiles = {};
        const photoFiles = [
          '001_Original.jpg', '016_Original.jpg', '017_Original.jpg', '024_Original.jpg',
          '027_Original.jpg', '055_Original.jpg', '071_Original.jpg', '114_Original.jpg',
          '121_Original.jpg', '142_Original.jpg', '196_Original.jpg', '211_Original.jpg',
          'A20926B7-DE97-4E84-AB81-0748BE55DBDA.JPG', 'CIMG9720.jpg',
          'IMG_0043.JPG', 'IMG_0485.JPG', 'IMG_1011.JPG', 'IMG_3324.JPG',
          'IMG_3384.JPG', 'IMG_5014.JPG', 'IMG_7435.jpg', 'IMG_7827.JPG',
          'IMG_8346.jpg', 'IMG_8626.JPG', 'IMG_8627.JPG', 'IMG_8628.JPG',
          'IMG_8634.JPG', 'IMG_8636.JPG', 'IMG_8860.JPG', 'IMG_8995.JPG',
          'IMG_9303.JPG', 'IMG_9442.JPG', 'IMG_9459.JPG', 'IMG_9933.jpg',
          'IMG_6455.PNG', 'IMG_7731.PNG',
          'IMG_0053.jpg', 'IMG_0184.jpg', 'IMG_0488.jpg', 'IMG_0526.jpg',
          'IMG_0536.jpg', 'IMG_0808.jpg', 'IMG_0890.jpg', 'IMG_1002.jpg',
          'IMG_1031.jpg', 'IMG_1053.jpg', 'IMG_1375.jpg', 'IMG_1452.jpg',
          'IMG_1469.jpg', 'IMG_1585.jpg', 'IMG_1624.jpg', 'IMG_1645.jpg',
          'IMG_1651.jpg', 'IMG_1657.jpg', 'IMG_1684.jpg', 'IMG_2163.jpg',
          'IMG_2449.jpg', 'IMG_2953.jpg', 'IMG_2978.jpg', 'IMG_2979 2.jpg',
          'IMG_2979.jpg', 'IMG_3013.jpg', 'IMG_3064.jpg', 'IMG_3082 2.jpg',
          'IMG_3126.jpg', 'IMG_3149.jpg', 'IMG_3261.jpg', 'IMG_3263.jpg',
          'IMG_3267.jpg', 'IMG_3522.jpg', 'IMG_3570.jpg', 'IMG_3583.jpg',
          'IMG_3631.jpg', 'IMG_3668.jpg', 'IMG_4003.jpg', 'IMG_4053.jpg',
          'IMG_4064.jpg', 'IMG_4146.jpg', 'IMG_4246 2.jpg', 'IMG_4289.jpg',
          'IMG_4310.jpg', 'IMG_4430.jpg', 'IMG_4443.jpg', 'IMG_4652.jpg',
          'IMG_4682.jpg', 'IMG_4699.jpg', 'IMG_5055.jpg', 'IMG_5101.jpg',
          'IMG_5116.jpg', 'IMG_5209.jpg', 'IMG_5222.jpg', 'IMG_5274.jpg',
          'IMG_5353.jpg', 'IMG_5379.jpg', 'IMG_5783.jpg', 'IMG_5840.jpg',
          'IMG_5899.jpg', 'IMG_6006.jpg', 'IMG_6307.jpg', 'IMG_6349.jpg',
          'IMG_6396.jpg', 'IMG_6646.jpg', 'IMG_6648.jpg', 'IMG_6789.jpg',
          'IMG_6825.jpg', 'IMG_6844.jpg', 'IMG_6957.jpg', 'IMG_7043.jpg',
          'IMG_7051.jpg', 'IMG_7064.jpg', 'IMG_7146.jpg', 'IMG_7308.jpg',
          'IMG_7506.jpg', 'IMG_7535.jpg', 'IMG_7600.jpg', 'IMG_7687.jpg',
          'IMG_7718.jpg', 'IMG_7734.jpg', 'IMG_7791.jpg', 'IMG_7824.jpg',
          'IMG_8316.jpg', 'IMG_8389.jpg', 'IMG_8468.jpg', 'IMG_8548.jpg',
          'IMG_8553.jpg', 'IMG_8561.jpg', 'IMG_8690.jpg', 'IMG_8701.jpg',
          'IMG_8746.jpg', 'IMG_8821.jpg', 'IMG_8823.jpg', 'IMG_8849.jpg',
          'IMG_8897.jpg', 'IMG_8901.jpg', 'IMG_8908.jpg', 'IMG_8926.jpg',
          'IMG_8952.jpg', 'IMG_9014.jpg', 'IMG_9021.jpg', 'IMG_9033.jpg',
          'IMG_9036.jpg', 'IMG_9057.jpg', 'IMG_9090.jpg', 'IMG_9111.jpg',
          'IMG_9122.jpg', 'IMG_9187.jpg', 'IMG_9229.jpg', 'IMG_9257.jpg',
          'IMG_9294.jpg', 'IMG_9309.jpg', 'IMG_9340.jpg', 'IMG_9356.jpg',
          'IMG_9378.jpg', 'IMG_9880.jpg', 'IMG_9925.jpg', 'IMG_9989.jpg'
        ];
        
        const videoFiles = [
          'IMG_0028.MOV', 'IMG_2205.MOV', 'IMG_4533.MOV', 'IMG_6397.MOV',
          'IMG_8583.MOV', 'IMG_8976.MOV', 'IMG_9317.MOV',
          'ScreenRecording_06-20-2025 21-16-11_1.mov',
          'Video Nov 08 2025, 5 12 28 PM.MOV',
          'Video Nov 08 2025, 7 45 13 PM.MOV'
        ];
        
        photoFiles.forEach(file => {
          fallbackFiles[file] = '2026-01-01';
        });
        
        videoFiles.forEach(file => {
          fallbackFiles[file] = '2026-01-01';
        });
        
        return fallbackFiles;
      }
      
      async setupPhotoStream() {
        const photoStreamContainer = document.getElementById('photoStream');
        
        // Use photos specifically from the landing page photos directory
        const landingPagePhotos = [
          'landing page photos/001_Original.jpg',
          'landing page photos/027_Original.jpg',
          'landing page photos/114_Original.jpg',
          'landing page photos/211_Original.jpg',
          'landing page photos/CIMG9720.jpg',
          'landing page photos/IMG_0485.JPG',
          'landing page photos/IMG_0488.jpeg',
          'landing page photos/IMG_0526.jpeg',
          'landing page photos/IMG_1651.jpeg',
          'landing page photos/IMG_1684.jpeg',
          'landing page photos/IMG_2449.jpeg',
          'landing page photos/IMG_3149.jpeg',
          'landing page photos/IMG_3324.JPG',
          'landing page photos/IMG_3522.jpeg',
          'landing page photos/IMG_3583.jpeg',
          'landing page photos/IMG_4064.jpeg',
          'landing page photos/IMG_6957.jpeg',
          'landing page photos/IMG_8901.jpeg',
          'landing page photos/IMG_9090.jpeg',
          'landing page photos/IMG_9229.jpeg',
          'landing page photos/IMG_9933.jpg'
        ];
        
        console.log(`üé¨ Loading ${landingPagePhotos.length} photos from landing page photos directory`);
        
        // Randomize the photo order using Fisher-Yates shuffle
        const shuffleArray = (array) => {
          const shuffled = [...array];
          for (let i = shuffled.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
          }
          return shuffled;
        };
        
        const randomizedPhotos = shuffleArray(landingPagePhotos);
        
        // Simple randomized layout centered around text
        const totalPhotos = randomizedPhotos.length;
        
        // Create photos with simple random positions
        randomizedPhotos.forEach((photoUrl, index) => {
          const container = document.createElement('div');
          container.className = 'photo-stream-item';
          
          // Random position in the middle of screen (centered around text)
          const basePosition = 15 + (index * (60 / totalPhotos));
          const randomOffset = (Math.random() - 0.5) * 10;
          const topPosition = basePosition + randomOffset;
          container.style.top = `${topPosition}%`;
          
          // Start from right side of screen (off-screen)
          container.style.left = '100vw';
          
          // Varied animation speeds
          const duration = 18 + (index % 3) * 4; // 18, 22, or 26 seconds
          container.style.animationDuration = `${duration}s`;
          
          // Staggered start times
          const delay = -(index * 1.2);
          container.style.animationDelay = `${delay}s`;
          
          // Alternate z-index
          const zIndex = index % 2 === 0 ? 15 : 5;
          container.style.zIndex = zIndex;
          
          const img = document.createElement('img');
          img.src = photoUrl;
          img.alt = 'Memory photo';
          img.className = 'stream-photo';
          
          // Initialize with GSAP for clean rendering (immediate)
          gsap.set(container, { 
            x: 0, 
            y: 0, 
            z: 0, 
            rotateY: 0, 
            rotateZ: 0, 
            scale: 1, 
            opacity: 0,
            force3D: true
          });
          
          let imageLoaded = false;
          img.onload = () => {
            imageLoaded = true;
            // Animate in when loaded
            gsap.to(container, {
              opacity: 1,
              duration: 0.5,
              ease: "power2.out"
            });
            console.log(`‚úÖ Loaded: ${photoUrl}`);
            console.log(`   Dimensions: ${img.naturalWidth} x ${img.naturalHeight}`);
          };
          img.onerror = () => {
            console.error(`‚ùå Failed to load: ${photoUrl}`);
            container.style.display = 'none';
          };
          
          container.appendChild(img);
          photoStreamContainer.appendChild(container);
          
          // Debug: log after 1 second if image loaded
          setTimeout(() => {
            if (!imageLoaded) {
              console.warn(`‚è≥ Still loading after 1s: ${photoUrl}`);
            }
          }, 1000);
        });
      }
      
      enterScrapbook() {
        this.landingActive = false;
        
        // Trigger the circular shuffle animation
        this.triggerCircularShuffleAnimation();
      }
      
      triggerCircularShuffleAnimation() {
        const landingPage = document.getElementById('landingPage');
        const landingTitle = document.getElementById('landingTitle');
        const photoStreamItems = document.querySelectorAll('.photo-stream-item');
        
        // Fade out title
        landingTitle.style.transition = 'opacity 0.8s ease';
        landingTitle.style.opacity = '0';
        
        // Fade out all photos with a gentle scale effect
        photoStreamItems.forEach((item, index) => {
          item.classList.add('fade-out');
          
          // Stagger slightly for elegance
          setTimeout(() => {
            item.style.opacity = '0';
            item.style.transform = 'scale(0.8)';
          }, index * 30);
        });
        
        // Fade out landing page
        setTimeout(() => {
          landingPage.style.transition = 'opacity 0.8s ease';
          landingPage.style.opacity = '0';
        }, 800);
        
        // Hide landing page and show main content
        setTimeout(() => {
          landingPage.classList.add('hidden');
          this.render();
        }, 1800);
      }
      
      setupEventListeners() {
        // Landing page title click
        document.getElementById('landingTitle').addEventListener('click', () => {
          this.enterScrapbook();
        });
        
        // Create memory button
        document.getElementById('createMemoryBtn').addEventListener('click', () => {
          this.openCreateModal();
        });
        
        // Cancel button
        document.getElementById('cancelBtn').addEventListener('click', () => {
          this.closeCreateModal();
        });
        
        // Close modal on backdrop click
        document.getElementById('createMemoryModal').addEventListener('click', (e) => {
          if (e.target.id === 'createMemoryModal') {
            this.closeCreateModal();
          }
        });
        
        // Memory type selection
        const typeOptions = document.querySelectorAll('.type-option');
        typeOptions.forEach(option => {
          option.addEventListener('click', (e) => {
            const selectedType = e.currentTarget.dataset.type;
            this.selectMemoryType(selectedType);
          });
        });
        
        // Form submission
        document.getElementById('createMemoryForm').addEventListener('submit', async (e) => {
          e.preventDefault();
          await this.handleCreateMemory(e);
        });
      }
      
      openCreateModal() {
        const modal = document.getElementById('createMemoryModal');
        modal.classList.add('active');
        
        // Set default date to today
        const today = new Date().toISOString().split('T')[0];
        document.getElementById('memoryDate').value = today;
      }
      
      closeCreateModal() {
        const modal = document.getElementById('createMemoryModal');
        modal.classList.remove('active');
        
        // Reset form
        document.getElementById('createMemoryForm').reset();
        document.querySelectorAll('.type-option').forEach(option => {
          option.classList.remove('active');
        });
        document.getElementById('memoryType').value = '';
        
        // Hide caption field on close
        document.getElementById('captionField').style.display = 'none';
        document.getElementById('memoryContent').placeholder = 'Select a memory type first...';
      }
      
      selectMemoryType(type) {
        // Update UI
        document.querySelectorAll('.type-option').forEach(option => {
          option.classList.toggle('active', option.dataset.type === type);
        });
        
        // Set hidden input value
        document.getElementById('memoryType').value = type;
        
        // Progressive disclosure: Show caption field only for photo/video
        const captionField = document.getElementById('captionField');
        const contentField = document.getElementById('memoryContent');
        
        if (type === 'photo' || type === 'video') {
          captionField.style.display = 'block';
          contentField.placeholder = `URL to ${type}`;
        } else if (type === 'letter') {
          captionField.style.display = 'none';
          contentField.placeholder = 'Your message...';
        }
      }
      
      async handleCreateMemory(e) {
        const formData = new FormData(e.target);
        const memoryData = {
          id: 'memory_' + Date.now(),
          type: formData.get('type'),
          title: formData.get('title'),
          date: formData.get('date'),
          content: formData.get('content') || '',
          caption: formData.get('caption') || ''
        };
        
        // Validate that a type is selected
        if (!memoryData.type) {
          alert('Please select a memory type');
          return;
        }
        
        // Auto-save immediately
        const saved = await this.saveMemory(memoryData);
        
        if (saved) {
          // Close modal and re-render
          this.closeCreateModal();
          this.render();
          console.log('Memory created and saved:', memoryData);
        }
      }
      
      async saveMemory(memoryData) {
        try {
          // Save to storage immediately
          await window.storage.set(`memory:${memoryData.id}`, JSON.stringify(memoryData));
          
          // Update in-memory array
          this.addMemoryToArray(memoryData);
          
          console.log('Memory auto-saved successfully');
          return true;
        } catch (error) {
          console.error('Auto-save failed:', error);
          alert('Failed to save memory. Please try again.');
          return false;
        }
      }
      
      addMemoryToArray(memoryData) {
        // Check if memory already exists
        const existingIndex = this.memories.findIndex(m => m.id === memoryData.id);
        if (existingIndex >= 0) {
          this.memories[existingIndex] = memoryData;
        } else {
          this.memories.push(memoryData);
        }
        
        // Re-sort chronologically (newest first)
        this.memories.sort((a, b) => new Date(b.date) - new Date(a.date));
      }
      
      render() {
        console.log('=== RENDER START ===');
        console.log(`Memories count: ${this.memories.length}`);
        
        const contentContainer = document.getElementById('app-content');
        if (!contentContainer) {
          console.error('ERROR: app-content container not found!');
          return;
        }
        
        console.log('Rendering carousel view');
        contentContainer.innerHTML = this.renderCarouselView();
        setTimeout(() => {
          this.setupCarousel();
        }, 100);
        
        console.log('=== RENDER COMPLETE ===');
      }
      
      renderCarouselView() {
        if (this.memories.length === 0) {
          return '<div class="content-placeholder"><p>No memories yet. Create your first one!</p></div>';
        }
        
        return `
          <div class="carousel-view">
            <div class="carousel-stage" id="carouselStage"></div>
          </div>
        `;
      }
      
      setupCarousel() {
        console.log('=== SETUP CAROUSEL START ===');
        
        const stage = document.getElementById('carouselStage');
        if (!stage) {
          console.error('Carousel stage not found');
          return;
        }
        
        // Only create visible cards based on peek + back stack zones
        const PEEKS_EACH_SIDE = 2;
        const BACK_VISIBLE = 3;
        const VISIBLE_RANGE = PEEKS_EACH_SIDE + BACK_VISIBLE; // 5 cards on each side
        this.carouselCards = [];
        
        // Create only the cards we need to show
        for (let i = 0; i < this.memories.length; i++) {
          const el = document.createElement('div');
          el.className = 'carousel-card';
          el.dataset.index = i;
          el.style.display = 'none'; // Hide by default
          stage.appendChild(el);
          this.carouselCards.push(el);
        }
        
        console.log(`Created ${this.carouselCards.length} carousel card containers`);
        
        // Add random bend/curl variations to each card
        this.carouselCards.forEach((card) => {
          // Extremely subtle tilts to prevent cropping
          const bx = gsap.utils.random(-0.5, 0.5);  // rotateX baseline
          const by = gsap.utils.random(-0.5, 0.5);  // rotateY baseline

          card.dataset.bx = bx.toFixed(2);
          card.dataset.by = by.toFixed(2);
        });
        
        // Load content for visible cards only
        this.updateVisibleCards();
        
        // Keyboard navigation
        this.carouselKeyboardHandler = (e) => {
          if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
            e.preventDefault();
            if (e.key === 'ArrowRight') this.carouselNext();
            if (e.key === 'ArrowLeft') this.carouselPrev();
          }
        };
        document.addEventListener('keydown', this.carouselKeyboardHandler);
        
        // Swipe gestures for touch devices
        this.setupCarouselSwipe(stage);
        
        console.log('=== SETUP CAROUSEL COMPLETE ===');
      }
      
      
      updateVisibleCards() {
        const index = this.carouselIndex;
        const n = this.memories.length;
        const PEEKS_EACH_SIDE = 2;
        const BACK_VISIBLE = 3;
        const range = PEEKS_EACH_SIDE + BACK_VISIBLE; // Total visible cards on each side
        
        // Determine which cards should be visible
        const visibleIndices = new Set();
        for (let offset = -range; offset <= range; offset++) {
          const idx = (index + offset + n) % n;
          visibleIndices.add(idx);
        }
        
        // Update each card
        this.carouselCards.forEach((card, i) => {
          if (visibleIndices.has(i)) {
            // Make visible and load content if needed
            if (card.style.display === 'none') {
              card.style.display = 'block';
              
              // Load content lazily
              if (!card.dataset.loaded) {
                const memory = this.memories[i];
                let mediaContent = '';
                
                if (memory.type === 'photo' && memory.content) {
                  mediaContent = `<img src="${memory.content}" alt="${memory.title}" decoding="async" />`;
                } else if (memory.type === 'video' && memory.content) {
                  // Note: autoplay is handled by layoutCarousel() when card is centered
                  mediaContent = `<video src="${memory.content}" muted playsinline loop preload="metadata"></video>`;
                } else {
                  mediaContent = `<div style="width:100%;height:100%;background:linear-gradient(135deg,#f093fb 0%,#f5576c 100%);"></div>`;
                }
                
                // Print container with effect layers
                card.innerHTML = `
                  <div class="print">
                    ${mediaContent}
                    <div class="paper"></div>
                    <div class="sheen"></div>
                  </div>
                `;
                card.dataset.loaded = 'true';
                
                // Add error handling for images
                const img = card.querySelector('img');
                if (img) {
                  img.onerror = () => {
                    console.error(`Failed to load image: ${memory.content}`);
                  };
                  img.onload = () => {
                    console.log(`Loaded image: ${memory.content}`);
                  };
                }
                
                // Initialize GSAP props with starting values for animation
                const isFirstLoad = !this.carouselInitialized;
                gsap.set(card, {
                  x: 0,
                  y: 0,
                  rotate: 0,
                  scale: isFirstLoad ? 0.85 : 1,
                  opacity: isFirstLoad ? 0 : 1,
                  transformOrigin: "50% 60%",
                  force3D: true
                });
              }
            }
          } else {
            // Hide cards that are too far away
            if (card.style.display !== 'none') {
              gsap.to(card, { 
                opacity: 0, 
                duration: 0.2,
                onComplete: () => {
                  card.style.display = 'none';
                }
              });
            }
          }
        });
        
        // Layout with smooth animation on initial load
        const isInitialLoad = !this.carouselInitialized;
        requestAnimationFrame(() => this.layoutCarousel(false, isInitialLoad));
        if (isInitialLoad) {
          this.carouselInitialized = true;
        }
      }
      
      setupCarouselSwipe(stackEl) {
        const canSwipe = window.matchMedia("(pointer: coarse)").matches;
        
        if (!canSwipe) {
          console.log('Not a touch device, skipping swipe setup');
          return;
        }
        
        console.log('Setting up swipe gestures');
        
        let startX = 0, startY = 0, dragging = false, draggedCard = null;
        const SWIPE_MIN_PX = 35;
        const SWIPE_MAX_Y = 60;
        
        stackEl.addEventListener("pointerdown", (e) => {
          if (this.carouselLocked) return;
          dragging = true;
          startX = e.clientX;
          startY = e.clientY;
          draggedCard = this.carouselCards[this.carouselIndex];
          stackEl.setPointerCapture(e.pointerId);
        }, { passive: true });
        
        stackEl.addEventListener("pointermove", (e) => {
          if (!dragging || this.carouselLocked || !draggedCard) return;
          
          const dx = e.clientX - startX;
          const dy = e.clientY - startY;
          
          // Use requestAnimationFrame for smoother drag
          if (!this.dragRaf) {
            this.dragRaf = requestAnimationFrame(() => {
              gsap.to(draggedCard, {
                y: dy * 0.15,
                z: Math.min(90, Math.abs(dx) * 0.6),
                rotateZ: dx * 0.02,
                rotateY: dx * 0.04,
                duration: 0.08,
                ease: "power2.out",
                force3D: true,
                overwrite: 'auto'
              });
              this.dragRaf = null;
            });
          }
        });
        
        stackEl.addEventListener("pointerup", (e) => {
          if (!dragging) return;
          dragging = false;
          
          const dx = e.clientX - startX;
          const dy = e.clientY - startY;
          
          if (!draggedCard) return;
          
          if (Math.abs(dy) > SWIPE_MAX_Y || Math.abs(dx) < SWIPE_MIN_PX) {
            gsap.to(draggedCard, {
              y: 0,
              z: 0,
              rotateZ: 0,
              rotateY: 0,
              duration: 0.25,
              ease: "power2.out",
              force3D: true
            });
            draggedCard = null;
            return;
          }
          
          draggedCard = null;
          if (dx > 0) this.carouselNext();
          else this.carouselPrev();
        });
        
        stackEl.addEventListener("pointercancel", () => {
          dragging = false;
          if (draggedCard) {
            gsap.to(draggedCard, {
              y: 0,
              z: 0,
              rotateZ: 0,
              rotateY: 0,
              duration: 0.25,
              ease: "power2.out",
              force3D: true
            });
            draggedCard = null;
          }
        });
      }
      
      layoutCarousel(immediate = false, isInitialLoad = false) {
        if (this.isTransitioning) return; // Don't restack mid-flight
        
        const n = this.carouselCards.length;
        const index = this.carouselIndex;
        
        // Layout zones: peek neighbors (small fan) + tight back stack
        const PEEKS_EACH_SIDE = 2;     // cards that fan out left/right
        const BACK_VISIBLE = 3;        // tight stack behind
        
        // Peek tuning (small fan, contained)
        const PEEK_X = 42;
        const PEEK_Y = 10;
        const PEEK_ROT = 4.5;
        const PEEK_SCALE_STEP = 0.03;
        
        // Back stack tuning (tight pile)
        const BACK_DX = 6;
        const BACK_DY = 6;
        const BACK_Z = 26;
        const BACK_ROT = -0.6;
        
        // Helper: shortest signed distance around the loop
        const signedDist = (i, idx) => {
          let d = i - idx;
          if (d > n / 2) d -= n;
          if (d < -n / 2) d += n;
          return d;
        };
        
        this.carouselCards.forEach((card, i) => {
          if (card.style.display === 'none') return; // Skip hidden cards
          
          const d = signedDist(i, index);
          
          const bx = parseFloat(card.dataset.bx || "0");
          const by = parseFloat(card.dataset.by || "0");
          
          const isTop = d === 0;
          const isPeek = Math.abs(d) <= PEEKS_EACH_SIDE && !isTop;
          
          let x = 0, y = 0, z = 0, rz = 0, s = 1, o = 1, zIndex = 0;
          
          // Calculate depth for damping rotation (less bend deeper in stack)
          const depth = Math.abs(d);
          const damp = 1 - depth * 0.12; // less bend deeper in the stack
          
          // Keep last moved card fully opaque
          const isLastMoved = card === this.lastMovedCard;
          
          if (isTop) {
            // Top card: hero
            x = 0; y = 0; z = 0;
            rz = 0;
            s = 1.03;
            o = 1;
            zIndex = 1000;
          } else if (isPeek) {
            // Peeking neighbors: small fan, contained
            const step = Math.abs(d);
            const dir = Math.sign(d); // -1 left, +1 right
            
            x = dir * (PEEK_X * step);
            y = PEEK_Y * step;
            z = -(step * 14); // slight depth so peeks still feel stacked
            rz = dir * (PEEK_ROT * step);
            
            s = 1 - (step * PEEK_SCALE_STEP);
            o = 0.92 - (step * 0.05);
            zIndex = 900 - step;
          } else {
            // Everything else: tight stack behind (only show a few)
            const depth = Math.abs(d);
            
            if (depth <= BACK_VISIBLE + PEEKS_EACH_SIDE) {
              const backStep = depth - PEEKS_EACH_SIDE; // start after peek range
              
              x = backStep * BACK_DX;
              y = backStep * BACK_DY;
              z = -(backStep * BACK_Z);
              rz = backStep * BACK_ROT;
              
              s = 1 - backStep * 0.028;
              o = 0.70 - backStep * 0.08;
              zIndex = 700 - backStep;
            } else {
              // hide far cards
              o = 0;
              zIndex = 0;
              z = -999;
            }
          }
          
          // Override opacity for last moved card
          if (isLastMoved) {
            o = 1;
          }
          
          const props = {
            x, y, z,
            rotateX: bx * 0.05 * damp,
            rotateY: by * 0.05 * damp,
            rotateZ: rz,
            scale: s,
            opacity: o,
            zIndex,
            filter: depth === 0 ? "brightness(1)" : "brightness(0.97)",
            duration: immediate ? 0 : (isInitialLoad ? 1.2 : 0.5),
            ease: "power4.out",
            force3D: true
          };
          
          // Add stagger delay for initial load
          if (isInitialLoad) {
            const depth = Math.abs(d);
            props.delay = depth * 0.08;
          }
          
          immediate ? gsap.set(card, props) : gsap.to(card, props);
          
          // Handle video autoplay for center card
          const video = card.querySelector('video');
          if (video) {
            if (isTop) {
              // Play video when it's the hero card
              if (video.paused) {
                video.currentTime = 0; // Start from beginning
                video.play().catch(err => {
                  console.log('Video autoplay prevented:', err);
                });
              }
            } else {
              // Pause and reset video when it's not centered
              if (!video.paused) {
                video.pause();
                video.currentTime = 0;
              }
            }
          }
        });
      }
      
      carouselPrev() {
        if (this.carouselLocked || this.isTransitioning) return;
        this.carouselLocked = true;
        this.isTransitioning = true;
        
        const n = this.carouselCards.length;
        
        // Move index back first
        this.carouselIndex = (this.carouselIndex - 1 + n) % n;
        
        // The card that should come to front
        const incoming = this.carouselCards[this.carouselIndex];
        
        // Track this card as last moved
        this.lastMovedCard = incoming;
        
        // Motion knobs - match forward animation
        const Z_STEP = 30;
        const LIFT_Y = 300;  // Same dramatic lift as forward
        const SLOT_Z = 400;  // Start deep behind
        
        const PEEKS_EACH_SIDE = 2;
        const BACK_VISIBLE = 3;
        const VISIBLE = PEEKS_EACH_SIDE + BACK_VISIBLE;
        const backDepth = Math.min(VISIBLE + 2, n - 1);
        
        const BACK_DX = 6, BACK_DY = 6, BACK_ROT = -0.6;
        const backPose = {
          x: backDepth * BACK_DX,
          y: backDepth * BACK_DY,
          z: -(backDepth * Z_STEP) - SLOT_Z,
          rotateZ: backDepth * BACK_ROT,
          scale: 1 - backDepth * 0.028
        };
        
        const bx = parseFloat(incoming.dataset.bx || "0");
        const by = parseFloat(incoming.dataset.by || "0");
        
        // Start deep behind the stack
        gsap.set(incoming, {
          ...backPose,
          y: backPose.y,
          rotateX: bx * 0.05,
          rotateY: by * 0.05,
          opacity: 1,
          zIndex: 9999
        });
        
        const tl = gsap.timeline({
          onComplete: () => {
            gsap.set(incoming, { zIndex: 0 });
            
            this.isTransitioning = false;
            
            // Restack everyone once
            this.updateVisibleCards();
            requestAnimationFrame(() => this.layoutCarousel(false));
            
            this.carouselLocked = false;
          }
        });
        
        // Stage 1: Lift HIGH from behind - rise above the stack (invisible)
        tl.to(incoming, {
          y: backPose.y - LIFT_Y,
          rotateZ: backPose.rotateZ - 8,
          rotateX: bx * 0.5,
          rotateY: by * 0.5,
          scale: 1.05,
          opacity: 0,  // Start invisible from deep behind
          duration: 0.30,
          ease: "power2.out"
        });
        
        // Stage 2: Come forward toward camera while still high (fade in to 75%)
        tl.to(incoming, {
          z: 50,  // Pop forward in front
          rotateZ: "-=5",
          opacity: 0.75,  // Fade in to 75% at highest point
          duration: 0.25,
          ease: "power2.out"
        });
        
        // Stage 3: Descend to hero position (full opacity)
        tl.to(incoming, {
          x: 0,
          y: 0,
          z: 0,
          rotateZ: 0,
          rotateX: bx * 0.05,
          rotateY: by * 0.05,
          scale: 1.03,
          opacity: 1,  // Full opacity at center
          duration: 0.35,
          ease: "sine.inOut"
        });
        
        // Stage 4: Final settle
        tl.to(incoming, {
          scale: 1.03,
          duration: 0.12,
          ease: "power1.out"
        });
      }
      
      carouselNext() {
        if (this.carouselLocked || this.isTransitioning) return;
        this.carouselLocked = true;
        this.isTransitioning = true;
        
        const card = this.carouselCards[this.carouselIndex];
        const n = this.carouselCards.length;
        
        // Track this card as last moved
        this.lastMovedCard = card;
        
        // Keep it above everything during the move
        gsap.set(card, { zIndex: 9999, opacity: 1 });
        
        // Motion constants
        const Z_STEP = 30;
        const LIFT_Y = 300;  // Lift VERY HIGH to clear the entire stack
        const SLOT_Z_EXTRA = 400;  // Go DEEP behind everything (peeks + back stack)
        
        const PEEKS_EACH_SIDE = 2;
        const BACK_VISIBLE = 3;
        const VISIBLE = PEEKS_EACH_SIDE + BACK_VISIBLE;
        const backDepth = Math.min(VISIBLE + 2, n - 1);
        
        const BACK_DX = 6, BACK_DY = 6, BACK_ROT = -0.6;
        const finalBack = {
          x: backDepth * BACK_DX,
          y: backDepth * BACK_DY,
          z: -(backDepth * Z_STEP),
          rotateZ: backDepth * BACK_ROT,
          scale: 1 - backDepth * 0.028
        };
        
        const bx = parseFloat(card.dataset.bx || "0");
        const by = parseFloat(card.dataset.by || "0");
        
        const tl = gsap.timeline({
          onComplete: () => {
            // Reorder after animation
            this.carouselIndex = (this.carouselIndex + 1) % n;
            
            // Snap to final back pose
            gsap.set(card, { ...finalBack, zIndex: 0 });
            
            this.isTransitioning = false;
            this.updateVisibleCards();
            requestAnimationFrame(() => this.layoutCarousel(false));
            
            this.carouselLocked = false;
          }
        });
        
        // Stage 1: Lift VERY HIGH - clear above the entire stack AND fanned cards
        tl.to(card, {
          y: `-=${LIFT_Y}`,
          z: 50,  // Pop forward so it's clearly above everything
          rotateZ: "+=5",
          rotateX: bx * 0.5,
          rotateY: by * 0.5,
          scale: 1.05,  // Keep it visible but not too big
          opacity: 0.75,  // 75% opacity at highest point
          duration: 0.30,
          ease: "power2.out"
        });
        
        // Stage 2: Immediately dive behind while still high up
        tl.to(card, {
          z: finalBack.z - SLOT_Z_EXTRA - 100,  // Go VERY deep negative immediately
          rotateZ: "+=10",
          scale: finalBack.scale,  // Keep normal scale
          opacity: 0.1,  // Start fading out
          duration: 0.25,
          ease: "power2.in"
        });
        
        // Stage 3: Now descend down behind the stack (fully invisible)
        tl.to(card, {
          x: finalBack.x,
          y: finalBack.y - 20,
          rotateZ: finalBack.rotateZ,
          rotateX: bx * 0.05,
          rotateY: by * 0.05,
          scale: finalBack.scale,
          opacity: 0,  // Fully invisible while descending
          duration: 0.35,
          ease: "sine.inOut"
        });
        
        // Stage 4: Final settle (stay invisible at back)
        tl.to(card, {
          y: finalBack.y,
          opacity: 0,  // Stay invisible at the back
          duration: 0.12,
          ease: "power1.out"
        });
      }
      
      
      
    }
    
    // Initialize app when DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
      // Check if GSAP is loaded
      if (typeof gsap !== 'undefined') {
        console.log('‚úÖ GSAP loaded successfully!');
        
        // Set global GSAP defaults for hardware acceleration
        gsap.defaults({ force3D: true });
      } else {
        console.error('‚ùå GSAP not loaded!');
      }
      
      window.app = new MemoryScrapbookApp();
      console.log('Memory Scrapbook App initialized');
    });
  </script>
</body>
</html>
